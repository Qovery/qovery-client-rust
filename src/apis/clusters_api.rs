/*
 * Qovery API
 *
 * - Qovery is the fastest way to deploy your full-stack apps on any Cloud provider. - ℹ️ The API is stable and still in development.
 *
 * The version of the OpenAPI document: 1.0.4
 * Contact: support+api+documentation@qovery.com
 * Generated by: https://openapi-generator.tech
 */

use super::{configuration, ContentType, Error};
use crate::{apis::ResponseContent, models};
use reqwest;
use serde::{de::Error as _, Deserialize, Serialize};

/// struct for typed errors of method [`create_cluster`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateClusterError {
    Status400(),
    Status401(),
    Status403(),
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_cluster`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteClusterError {
    Status401(),
    Status403(),
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`deploy_cluster`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeployClusterError {
    Status400(),
    Status401(),
    Status403(),
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`edit_cluster`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum EditClusterError {
    Status400(),
    Status401(),
    Status403(),
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`edit_cluster_advanced_settings`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum EditClusterAdvancedSettingsError {
    Status400(),
    Status401(),
    Status403(),
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`edit_cluster_kubeconfig`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum EditClusterKubeconfigError {
    Status401(),
    Status403(),
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`edit_routing_table`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum EditRoutingTableError {
    Status400(),
    Status401(),
    Status403(),
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_cluster_advanced_settings`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetClusterAdvancedSettingsError {
    Status401(),
    Status403(),
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_cluster_kubeconfig`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetClusterKubeconfigError {
    Status401(),
    Status403(),
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_cluster_kubernetes_events`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetClusterKubernetesEventsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_cluster_metrics`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetClusterMetricsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_cluster_readiness_status`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetClusterReadinessStatusError {
    Status401(),
    Status403(),
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_cluster_status`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetClusterStatusError {
    Status401(),
    Status403(),
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_default_cluster_advanced_settings`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetDefaultClusterAdvancedSettingsError {
    Status401(),
    Status403(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_installation_helm_values`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetInstallationHelmValuesError {
    Status401(),
    Status403(),
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_organization_cloud_provider_info`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetOrganizationCloudProviderInfoError {
    Status401(),
    Status403(),
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_organization_cluster_status`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetOrganizationClusterStatusError {
    Status401(),
    Status403(),
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_routing_table`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetRoutingTableError {
    Status401(),
    Status403(),
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`list_cluster_logs`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListClusterLogsError {
    Status401(),
    Status403(),
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`list_organization_cluster`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListOrganizationClusterError {
    Status401(),
    Status403(),
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`lock_cluster`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum LockClusterError {
    Status401(),
    Status403(),
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`specify_cluster_cloud_provider_info`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SpecifyClusterCloudProviderInfoError {
    Status400(),
    Status401(),
    Status403(),
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`stop_cluster`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StopClusterError {
    Status401(),
    Status403(),
    Status404(),
    Status409(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`unlock_cluster`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UnlockClusterError {
    Status401(),
    Status403(),
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_karpenter_private_fargate_subnet_ids`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateKarpenterPrivateFargateSubnetIdsError {
    Status400(),
    Status401(),
    Status403(),
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`upgrade_cluster`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpgradeClusterError {
    Status400(),
    Status401(),
    Status403(),
    Status404(),
    UnknownValue(serde_json::Value),
}

pub async fn create_cluster(
    configuration: &configuration::Configuration,
    organization_id: &str,
    cluster_request: Option<models::ClusterRequest>,
) -> Result<models::Cluster, Error<CreateClusterError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_organization_id = organization_id;
    let p_cluster_request = cluster_request;

    let uri_str = format!(
        "{}/organization/{organizationId}/cluster",
        configuration.base_path,
        organizationId = crate::apis::urlencode(p_organization_id)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_cluster_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::Cluster`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::Cluster`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CreateClusterError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn delete_cluster(
    configuration: &configuration::Configuration,
    organization_id: &str,
    cluster_id: &str,
    delete_mode: Option<models::ClusterDeleteMode>,
) -> Result<(), Error<DeleteClusterError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_organization_id = organization_id;
    let p_cluster_id = cluster_id;
    let p_delete_mode = delete_mode;

    let uri_str = format!(
        "{}/organization/{organizationId}/cluster/{clusterId}",
        configuration.base_path,
        organizationId = crate::apis::urlencode(p_organization_id),
        clusterId = crate::apis::urlencode(p_cluster_id)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref param_value) = p_delete_mode {
        req_builder = req_builder.query(&[("deleteMode", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<DeleteClusterError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// allows to deploy a cluster
pub async fn deploy_cluster(
    configuration: &configuration::Configuration,
    organization_id: &str,
    cluster_id: &str,
    dry_run: Option<bool>,
) -> Result<models::ClusterStatus, Error<DeployClusterError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_organization_id = organization_id;
    let p_cluster_id = cluster_id;
    let p_dry_run = dry_run;

    let uri_str = format!(
        "{}/organization/{organizationId}/cluster/{clusterId}/deploy",
        configuration.base_path,
        organizationId = crate::apis::urlencode(p_organization_id),
        clusterId = crate::apis::urlencode(p_cluster_id)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = p_dry_run {
        req_builder = req_builder.query(&[("dry_run", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ClusterStatus`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ClusterStatus`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<DeployClusterError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn edit_cluster(
    configuration: &configuration::Configuration,
    organization_id: &str,
    cluster_id: &str,
    cluster_request: Option<models::ClusterRequest>,
) -> Result<models::Cluster, Error<EditClusterError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_organization_id = organization_id;
    let p_cluster_id = cluster_id;
    let p_cluster_request = cluster_request;

    let uri_str = format!(
        "{}/organization/{organizationId}/cluster/{clusterId}",
        configuration.base_path,
        organizationId = crate::apis::urlencode(p_organization_id),
        clusterId = crate::apis::urlencode(p_cluster_id)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_cluster_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::Cluster`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::Cluster`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<EditClusterError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Edit advanced settings by returning table of advanced settings.
pub async fn edit_cluster_advanced_settings(
    configuration: &configuration::Configuration,
    organization_id: &str,
    cluster_id: &str,
    cluster_advanced_settings: Option<models::ClusterAdvancedSettings>,
) -> Result<models::ClusterAdvancedSettings, Error<EditClusterAdvancedSettingsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_organization_id = organization_id;
    let p_cluster_id = cluster_id;
    let p_cluster_advanced_settings = cluster_advanced_settings;

    let uri_str = format!(
        "{}/organization/{organizationId}/cluster/{clusterId}/advancedSettings",
        configuration.base_path,
        organizationId = crate::apis::urlencode(p_organization_id),
        clusterId = crate::apis::urlencode(p_cluster_id)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_cluster_advanced_settings);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ClusterAdvancedSettings`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ClusterAdvancedSettings`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<EditClusterAdvancedSettingsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn edit_cluster_kubeconfig(
    configuration: &configuration::Configuration,
    organization_id: &str,
    cluster_id: &str,
    body: Option<&str>,
) -> Result<(), Error<EditClusterKubeconfigError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_organization_id = organization_id;
    let p_cluster_id = cluster_id;
    let p_body = body;

    let uri_str = format!(
        "{}/organization/{organizationId}/cluster/{clusterId}/kubeconfig",
        configuration.base_path,
        organizationId = crate::apis::urlencode(p_organization_id),
        clusterId = crate::apis::urlencode(p_cluster_id)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<EditClusterKubeconfigError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Edit routing table by returning updated table.
pub async fn edit_routing_table(
    configuration: &configuration::Configuration,
    organization_id: &str,
    cluster_id: &str,
    cluster_routing_table_request: Option<models::ClusterRoutingTableRequest>,
) -> Result<models::ClusterRoutingTable, Error<EditRoutingTableError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_organization_id = organization_id;
    let p_cluster_id = cluster_id;
    let p_cluster_routing_table_request = cluster_routing_table_request;

    let uri_str = format!(
        "{}/organization/{organizationId}/cluster/{clusterId}/routingTable",
        configuration.base_path,
        organizationId = crate::apis::urlencode(p_organization_id),
        clusterId = crate::apis::urlencode(p_cluster_id)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_cluster_routing_table_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ClusterRoutingTable`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ClusterRoutingTable`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<EditRoutingTableError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Get the list and values of the advanced settings of the cluster. Default values for each setting are available in [our documentation](https://hub.qovery.com/docs/using-qovery/configuration/cluster-advanced-settings/)
pub async fn get_cluster_advanced_settings(
    configuration: &configuration::Configuration,
    organization_id: &str,
    cluster_id: &str,
) -> Result<models::ClusterAdvancedSettings, Error<GetClusterAdvancedSettingsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_organization_id = organization_id;
    let p_cluster_id = cluster_id;

    let uri_str = format!(
        "{}/organization/{organizationId}/cluster/{clusterId}/advancedSettings",
        configuration.base_path,
        organizationId = crate::apis::urlencode(p_organization_id),
        clusterId = crate::apis::urlencode(p_cluster_id)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ClusterAdvancedSettings`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ClusterAdvancedSettings`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetClusterAdvancedSettingsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn get_cluster_kubeconfig(
    configuration: &configuration::Configuration,
    organization_id: &str,
    cluster_id: &str,
    with_token_from_cli: Option<bool>,
) -> Result<String, Error<GetClusterKubeconfigError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_organization_id = organization_id;
    let p_cluster_id = cluster_id;
    let p_with_token_from_cli = with_token_from_cli;

    let uri_str = format!(
        "{}/organization/{organizationId}/cluster/{clusterId}/kubeconfig",
        configuration.base_path,
        organizationId = crate::apis::urlencode(p_organization_id),
        clusterId = crate::apis::urlencode(p_cluster_id)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_with_token_from_cli {
        req_builder = req_builder.query(&[("with_token_from_cli", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `String`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `String`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetClusterKubeconfigError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// List Cluster Kubernetes Events
pub async fn get_cluster_kubernetes_events(
    configuration: &configuration::Configuration,
    cluster_id: &str,
    from_date_time: &str,
    to_date_time: &str,
    node_name: Option<&str>,
    pod_name: Option<&str>,
    reporting_component: Option<&str>,
) -> Result<models::GetClusterKubernetesEvents200Response, Error<GetClusterKubernetesEventsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_cluster_id = cluster_id;
    let p_from_date_time = from_date_time;
    let p_to_date_time = to_date_time;
    let p_node_name = node_name;
    let p_pod_name = pod_name;
    let p_reporting_component = reporting_component;

    let uri_str = format!(
        "{}/cluster/{clusterId}/events",
        configuration.base_path,
        clusterId = crate::apis::urlencode(p_cluster_id)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("from_date_time", &p_from_date_time.to_string())]);
    req_builder = req_builder.query(&[("to_date_time", &p_to_date_time.to_string())]);
    if let Some(ref param_value) = p_node_name {
        req_builder = req_builder.query(&[("node_name", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_pod_name {
        req_builder = req_builder.query(&[("pod_name", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_reporting_component {
        req_builder = req_builder.query(&[("reporting_component", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetClusterKubernetesEvents200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetClusterKubernetesEvents200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetClusterKubernetesEventsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Fetch cluster metrics
pub async fn get_cluster_metrics(
    configuration: &configuration::Configuration,
    cluster_id: &str,
    endpoint: &str,
    query: &str,
    start: Option<&str>,
    end: Option<&str>,
    step: Option<&str>,
    time: Option<&str>,
    timeout: Option<&str>,
    dedup: Option<&str>,
    partial_response: Option<&str>,
    max_source_resolution: Option<&str>,
) -> Result<models::ClusterMetricsResponse, Error<GetClusterMetricsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_cluster_id = cluster_id;
    let p_endpoint = endpoint;
    let p_query = query;
    let p_start = start;
    let p_end = end;
    let p_step = step;
    let p_time = time;
    let p_timeout = timeout;
    let p_dedup = dedup;
    let p_partial_response = partial_response;
    let p_max_source_resolution = max_source_resolution;

    let uri_str = format!(
        "{}/cluster/{clusterId}/metrics",
        configuration.base_path,
        clusterId = crate::apis::urlencode(p_cluster_id)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("endpoint", &p_endpoint.to_string())]);
    req_builder = req_builder.query(&[("query", &p_query.to_string())]);
    if let Some(ref param_value) = p_start {
        req_builder = req_builder.query(&[("start", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_end {
        req_builder = req_builder.query(&[("end", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_step {
        req_builder = req_builder.query(&[("step", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_time {
        req_builder = req_builder.query(&[("time", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_timeout {
        req_builder = req_builder.query(&[("timeout", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_dedup {
        req_builder = req_builder.query(&[("dedup", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_partial_response {
        req_builder = req_builder.query(&[("partial_response", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_max_source_resolution {
        req_builder = req_builder.query(&[("max_source_resolution", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ClusterMetricsResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ClusterMetricsResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetClusterMetricsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn get_cluster_readiness_status(
    configuration: &configuration::Configuration,
    organization_id: &str,
    cluster_id: &str,
) -> Result<models::ClusterReadinessStatus, Error<GetClusterReadinessStatusError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_organization_id = organization_id;
    let p_cluster_id = cluster_id;

    let uri_str = format!(
        "{}/organization/{organizationId}/cluster/{clusterId}/isReady",
        configuration.base_path,
        organizationId = crate::apis::urlencode(p_organization_id),
        clusterId = crate::apis::urlencode(p_cluster_id)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ClusterReadinessStatus`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ClusterReadinessStatus`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetClusterReadinessStatusError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn get_cluster_status(
    configuration: &configuration::Configuration,
    organization_id: &str,
    cluster_id: &str,
) -> Result<models::ClusterStatus, Error<GetClusterStatusError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_organization_id = organization_id;
    let p_cluster_id = cluster_id;

    let uri_str = format!(
        "{}/organization/{organizationId}/cluster/{clusterId}/status",
        configuration.base_path,
        organizationId = crate::apis::urlencode(p_organization_id),
        clusterId = crate::apis::urlencode(p_cluster_id)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ClusterStatus`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ClusterStatus`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetClusterStatusError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Default values for each setting are available in [our documentation](https://hub.qovery.com/docs/using-qovery/configuration/cluster-advanced-settings/)
pub async fn get_default_cluster_advanced_settings(
    configuration: &configuration::Configuration,
) -> Result<models::ClusterAdvancedSettings, Error<GetDefaultClusterAdvancedSettingsError>> {
    let uri_str = format!("{}/defaultClusterAdvancedSettings", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ClusterAdvancedSettings`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ClusterAdvancedSettings`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetDefaultClusterAdvancedSettingsError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn get_installation_helm_values(
    configuration: &configuration::Configuration,
    organization_id: &str,
    cluster_id: &str,
) -> Result<String, Error<GetInstallationHelmValuesError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_organization_id = organization_id;
    let p_cluster_id = cluster_id;

    let uri_str = format!(
        "{}/organization/{organizationId}/cluster/{clusterId}/installationHelmValues",
        configuration.base_path,
        organizationId = crate::apis::urlencode(p_organization_id),
        clusterId = crate::apis::urlencode(p_cluster_id)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `String`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `String`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetInstallationHelmValuesError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn get_organization_cloud_provider_info(
    configuration: &configuration::Configuration,
    organization_id: &str,
    cluster_id: &str,
) -> Result<models::ClusterCloudProviderInfo, Error<GetOrganizationCloudProviderInfoError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_organization_id = organization_id;
    let p_cluster_id = cluster_id;

    let uri_str = format!(
        "{}/organization/{organizationId}/cluster/{clusterId}/cloudProviderInfo",
        configuration.base_path,
        organizationId = crate::apis::urlencode(p_organization_id),
        clusterId = crate::apis::urlencode(p_cluster_id)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ClusterCloudProviderInfo`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ClusterCloudProviderInfo`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetOrganizationCloudProviderInfoError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Returns a list of clusters with only their id and status.
pub async fn get_organization_cluster_status(
    configuration: &configuration::Configuration,
    organization_id: &str,
) -> Result<models::ClusterStatusResponseList, Error<GetOrganizationClusterStatusError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_organization_id = organization_id;

    let uri_str = format!(
        "{}/organization/{organizationId}/cluster/status",
        configuration.base_path,
        organizationId = crate::apis::urlencode(p_organization_id)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ClusterStatusResponseList`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ClusterStatusResponseList`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetOrganizationClusterStatusError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Retrieve network routing table where each line corresponds to a route between a destination and a target.
pub async fn get_routing_table(
    configuration: &configuration::Configuration,
    organization_id: &str,
    cluster_id: &str,
) -> Result<models::ClusterRoutingTable, Error<GetRoutingTableError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_organization_id = organization_id;
    let p_cluster_id = cluster_id;

    let uri_str = format!(
        "{}/organization/{organizationId}/cluster/{clusterId}/routingTable",
        configuration.base_path,
        organizationId = crate::apis::urlencode(p_organization_id),
        clusterId = crate::apis::urlencode(p_cluster_id)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ClusterRoutingTable`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ClusterRoutingTable`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetRoutingTableError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// List Cluster Logs
pub async fn list_cluster_logs(
    configuration: &configuration::Configuration,
    organization_id: &str,
    cluster_id: &str,
) -> Result<models::ClusterLogsResponseList, Error<ListClusterLogsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_organization_id = organization_id;
    let p_cluster_id = cluster_id;

    let uri_str = format!(
        "{}/organization/{organizationId}/cluster/{clusterId}/logs",
        configuration.base_path,
        organizationId = crate::apis::urlencode(p_organization_id),
        clusterId = crate::apis::urlencode(p_cluster_id)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ClusterLogsResponseList`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ClusterLogsResponseList`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ListClusterLogsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn list_organization_cluster(
    configuration: &configuration::Configuration,
    organization_id: &str,
) -> Result<models::ClusterResponseList, Error<ListOrganizationClusterError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_organization_id = organization_id;

    let uri_str = format!(
        "{}/organization/{organizationId}/cluster",
        configuration.base_path,
        organizationId = crate::apis::urlencode(p_organization_id)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ClusterResponseList`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ClusterResponseList`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ListOrganizationClusterError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Lock a Cluster
pub async fn lock_cluster(
    configuration: &configuration::Configuration,
    cluster_id: &str,
    cluster_lock_request: Option<models::ClusterLockRequest>,
) -> Result<models::ClusterLock, Error<LockClusterError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_cluster_id = cluster_id;
    let p_cluster_lock_request = cluster_lock_request;

    let uri_str = format!(
        "{}/cluster/{clusterId}/lock",
        configuration.base_path,
        clusterId = crate::apis::urlencode(p_cluster_id)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_cluster_lock_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ClusterLock`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ClusterLock`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<LockClusterError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn specify_cluster_cloud_provider_info(
    configuration: &configuration::Configuration,
    organization_id: &str,
    cluster_id: &str,
    cluster_cloud_provider_info_request: Option<models::ClusterCloudProviderInfoRequest>,
) -> Result<models::ClusterCloudProviderInfo, Error<SpecifyClusterCloudProviderInfoError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_organization_id = organization_id;
    let p_cluster_id = cluster_id;
    let p_cluster_cloud_provider_info_request = cluster_cloud_provider_info_request;

    let uri_str = format!(
        "{}/organization/{organizationId}/cluster/{clusterId}/cloudProviderInfo",
        configuration.base_path,
        organizationId = crate::apis::urlencode(p_organization_id),
        clusterId = crate::apis::urlencode(p_cluster_id)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_cluster_cloud_provider_info_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ClusterCloudProviderInfo`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ClusterCloudProviderInfo`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SpecifyClusterCloudProviderInfoError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Cluster stop has been requester.
pub async fn stop_cluster(
    configuration: &configuration::Configuration,
    organization_id: &str,
    cluster_id: &str,
) -> Result<models::ClusterStatus, Error<StopClusterError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_organization_id = organization_id;
    let p_cluster_id = cluster_id;

    let uri_str = format!(
        "{}/organization/{organizationId}/cluster/{clusterId}/stop",
        configuration.base_path,
        organizationId = crate::apis::urlencode(p_organization_id),
        clusterId = crate::apis::urlencode(p_cluster_id)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ClusterStatus`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ClusterStatus`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<StopClusterError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Unlock a cluster
pub async fn unlock_cluster(
    configuration: &configuration::Configuration,
    cluster_id: &str,
) -> Result<(), Error<UnlockClusterError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_cluster_id = cluster_id;

    let uri_str = format!(
        "{}/cluster/{clusterId}/lock",
        configuration.base_path,
        clusterId = crate::apis::urlencode(p_cluster_id)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<UnlockClusterError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Update karpenter private fargate subnet ids
pub async fn update_karpenter_private_fargate_subnet_ids(
    configuration: &configuration::Configuration,
    organization_id: &str,
    cluster_id: &str,
    cluster_karpenter_private_subnet_ids_put_request: Option<
        models::ClusterKarpenterPrivateSubnetIdsPutRequest,
    >,
) -> Result<(), Error<UpdateKarpenterPrivateFargateSubnetIdsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_organization_id = organization_id;
    let p_cluster_id = cluster_id;
    let p_cluster_karpenter_private_subnet_ids_put_request =
        cluster_karpenter_private_subnet_ids_put_request;

    let uri_str = format!(
        "{}/organization/{organizationId}/cluster/{clusterId}/karpenterPrivateSubnetIds",
        configuration.base_path,
        organizationId = crate::apis::urlencode(p_organization_id),
        clusterId = crate::apis::urlencode(p_cluster_id)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_cluster_karpenter_private_subnet_ids_put_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<UpdateKarpenterPrivateFargateSubnetIdsError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// allows to upgrade a cluster to next available kubernetes version
pub async fn upgrade_cluster(
    configuration: &configuration::Configuration,
    cluster_id: &str,
) -> Result<models::ClusterStatus, Error<UpgradeClusterError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_cluster_id = cluster_id;

    let uri_str = format!(
        "{}/cluster/{clusterId}/upgrade",
        configuration.base_path,
        clusterId = crate::apis::urlencode(p_cluster_id)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ClusterStatus`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ClusterStatus`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<UpgradeClusterError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}
