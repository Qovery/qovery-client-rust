/*
 * Qovery API
 *
 * - Qovery is the fastest way to deploy your full-stack apps on any Cloud provider. - ℹ️ The API is stable and still in development.
 *
 * The version of the OpenAPI document: 1.0.4
 * Contact: support+api+documentation@qovery.com
 * Generated by: https://openapi-generator.tech
 */

use crate::models;
use serde::{Deserialize, Serialize};

#[derive(Clone, Default, Debug, PartialEq, Serialize, Deserialize)]
pub struct ApplicationAdvancedSettings {
    /// disable custom domain check when deploying an application
    #[serde(
        rename = "deployment.custom_domain_check_enabled",
        skip_serializing_if = "Option::is_none"
    )]
    pub deployment_period_custom_domain_check_enabled: Option<bool>,
    /// define how long in seconds an application is supposed to be stopped gracefully
    #[serde(
        rename = "deployment.termination_grace_period_seconds",
        skip_serializing_if = "Option::is_none"
    )]
    pub deployment_period_termination_grace_period_seconds: Option<i32>,
    /// Set pod placement on specific Kubernetes nodes labels
    #[serde(
        rename = "deployment.affinity.node.required",
        skip_serializing_if = "Option::is_none"
    )]
    pub deployment_period_affinity_period_node_period_required:
        Option<std::collections::HashMap<String, String>>,
    /// Define how you want pods affinity to behave: * `Preferred` allows, but does not require, pods of a given service are not co-located (or co-hosted) on a single node * `Requirred` ensures that the pods of a given service are not co-located (or co-hosted) on a single node (safer in term of availability but can be expensive depending on the number of replicas)
    #[serde(
        rename = "deployment.antiaffinity.pod",
        skip_serializing_if = "Option::is_none"
    )]
    pub deployment_period_antiaffinity_period_pod: Option<DeploymentPeriodAntiaffinityPeriodPod>,
    /// Allows you to run a command after the application is started. The command should be a shell command or script.
    #[serde(
        rename = "deployment.lifecycle.post_start_exec_command",
        skip_serializing_if = "Option::is_none"
    )]
    pub deployment_period_lifecycle_period_post_start_exec_command: Option<Vec<String>>,
    /// Allows you to run a command before the application is stopped. The command should be a shell command or script. Qovery requires the sh shell by default and sets a sleep of 15 seconds to let Nginx update its config. Avoiding error codes returned during a rolling update.
    #[serde(
        rename = "deployment.lifecycle.pre_stop_exec_command",
        skip_serializing_if = "Option::is_none"
    )]
    pub deployment_period_lifecycle_period_pre_stop_exec_command: Option<Vec<String>>,
    /// * `RollingUpdate` gracefully rollout new versions, and automatically rollback if the new version fails to start * `Recreate` stop all current versions and create new ones once all old ones have been shutdown
    #[serde(
        rename = "deployment.update_strategy.type",
        skip_serializing_if = "Option::is_none"
    )]
    pub deployment_period_update_strategy_period_type:
        Option<DeploymentPeriodUpdateStrategyPeriodType>,
    /// Define the percentage of a maximum number of pods that can be unavailable during the update process
    #[serde(
        rename = "deployment.update_strategy.rolling_update.max_unavailable_percent",
        skip_serializing_if = "Option::is_none"
    )]
    pub deployment_period_update_strategy_period_rolling_update_period_max_unavailable_percent:
        Option<i32>,
    /// Define the percentage of the maximum number of pods that can be created over the desired number of pods
    #[serde(
        rename = "deployment.update_strategy.rolling_update.max_surge_percent",
        skip_serializing_if = "Option::is_none"
    )]
    pub deployment_period_update_strategy_period_rolling_update_period_max_surge_percent:
        Option<i32>,
    #[serde(
        rename = "build.timeout_max_sec",
        skip_serializing_if = "Option::is_none"
    )]
    pub build_period_timeout_max_sec: Option<i32>,
    /// define the max cpu resources (in milli)
    #[serde(
        rename = "build.cpu_max_in_milli",
        skip_serializing_if = "Option::is_none"
    )]
    pub build_period_cpu_max_in_milli: Option<i32>,
    /// define the max ram resources (in gib)
    #[serde(
        rename = "build.ram_max_in_gib",
        skip_serializing_if = "Option::is_none"
    )]
    pub build_period_ram_max_in_gib: Option<i32>,
    /// disable buildkit registry cache during build
    #[serde(
        rename = "build.disable_buildkit_cache",
        skip_serializing_if = "Option::is_none"
    )]
    pub build_period_disable_buildkit_cache: Option<bool>,
    #[serde(
        rename = "network.ingress.proxy_body_size_mb",
        skip_serializing_if = "Option::is_none"
    )]
    pub network_period_ingress_period_proxy_body_size_mb: Option<i32>,
    /// When using SSL offloading outside of cluster, you can enforce a redirect to HTTPS even when there is no TLS certificate available
    #[serde(
        rename = "network.ingress.force_ssl_redirect",
        skip_serializing_if = "Option::is_none"
    )]
    pub network_period_ingress_period_force_ssl_redirect: Option<bool>,
    #[serde(
        rename = "network.ingress.enable_cors",
        skip_serializing_if = "Option::is_none"
    )]
    pub network_period_ingress_period_enable_cors: Option<bool>,
    #[serde(
        rename = "network.ingress.cors_allow_origin",
        skip_serializing_if = "Option::is_none"
    )]
    pub network_period_ingress_period_cors_allow_origin: Option<String>,
    #[serde(
        rename = "network.ingress.cors_allow_methods",
        skip_serializing_if = "Option::is_none"
    )]
    pub network_period_ingress_period_cors_allow_methods: Option<String>,
    #[serde(
        rename = "network.ingress.cors_allow_headers",
        skip_serializing_if = "Option::is_none"
    )]
    pub network_period_ingress_period_cors_allow_headers: Option<String>,
    /// header buffer size used while reading response header from upstream
    #[serde(
        rename = "network.ingress.proxy_buffer_size_kb",
        skip_serializing_if = "Option::is_none"
    )]
    pub network_period_ingress_period_proxy_buffer_size_kb: Option<i32>,
    /// Limits the maximum time (in seconds) during which requests can be processed through one keepalive connection
    #[serde(
        rename = "network.ingress.keepalive_time_seconds",
        skip_serializing_if = "Option::is_none"
    )]
    pub network_period_ingress_period_keepalive_time_seconds: Option<i32>,
    /// Sets a timeout (in seconds) during which an idle keepalive connection to an upstream server will stay open.
    #[serde(
        rename = "network.ingress.keepalive_timeout_seconds",
        skip_serializing_if = "Option::is_none"
    )]
    pub network_period_ingress_period_keepalive_timeout_seconds: Option<i32>,
    /// Sets a timeout (in seconds) for transmitting a response to the client
    #[serde(
        rename = "network.ingress.send_timeout_seconds",
        skip_serializing_if = "Option::is_none"
    )]
    pub network_period_ingress_period_send_timeout_seconds: Option<i32>,
    /// Sets a timeout (in seconds) for establishing a connection to a proxied server
    #[serde(
        rename = "network.ingress.proxy_connect_timeout_seconds",
        skip_serializing_if = "Option::is_none"
    )]
    pub network_period_ingress_period_proxy_connect_timeout_seconds: Option<i32>,
    /// Sets a timeout (in seconds) for transmitting a request to the proxied server
    #[serde(
        rename = "network.ingress.proxy_send_timeout_seconds",
        skip_serializing_if = "Option::is_none"
    )]
    pub network_period_ingress_period_proxy_send_timeout_seconds: Option<i32>,
    /// Sets a timeout (in seconds) for reading a response from the proxied server
    #[serde(
        rename = "network.ingress.proxy_read_timeout_seconds",
        skip_serializing_if = "Option::is_none"
    )]
    pub network_period_ingress_period_proxy_read_timeout_seconds: Option<i32>,
    /// Allows to enable or disable nginx `proxy-request-buffering`
    #[serde(
        rename = "network.ingress.proxy_buffering",
        skip_serializing_if = "Option::is_none"
    )]
    pub network_period_ingress_period_proxy_buffering: Option<String>,
    /// list of source ranges to allow access to ingress proxy.  This property can be used to whitelist source IP ranges for ingress proxy. The value is a comma separated list of CIDRs, e.g. 10.0.0.0/24,172.10.0.1 To allow all source ranges, set 0.0.0.0/0.
    #[serde(
        rename = "network.ingress.whitelist_source_range",
        skip_serializing_if = "Option::is_none"
    )]
    pub network_period_ingress_period_whitelist_source_range: Option<String>,
    /// list of source ranges to deny access to ingress proxy.  This property can be used to blacklist source IP ranges for ingress proxy. The value is a comma separated list of CIDRs, e.g. 10.0.0.0/24,172.10.0.1
    #[serde(
        rename = "network.ingress.denylist_source_range",
        skip_serializing_if = "Option::is_none"
    )]
    pub network_period_ingress_period_denylist_source_range: Option<String>,
    /// Set the name of an environment variable to use as a basic authentication (`login:crypted_password`) from `htpasswd` command.
    #[serde(
        rename = "network.ingress.basic_auth_env_var",
        skip_serializing_if = "Option::is_none"
    )]
    pub network_period_ingress_period_basic_auth_env_var: Option<String>,
    /// Enable the load balancer to bind a user's session to a specific target. This ensures that all requests from the user during the session are sent to the same target
    #[serde(
        rename = "network.ingress.enable_sticky_session",
        skip_serializing_if = "Option::is_none"
    )]
    pub network_period_ingress_period_enable_sticky_session: Option<bool>,
    /// Sets a timeout (in seconds) for transmitting a request to the grpc server
    #[serde(
        rename = "network.ingress.grpc_send_timeout_seconds",
        skip_serializing_if = "Option::is_none"
    )]
    pub network_period_ingress_period_grpc_send_timeout_seconds: Option<i32>,
    /// Sets a timeout (in seconds) for transmitting a request to the grpc server
    #[serde(
        rename = "network.ingress.grpc_read_timeout_seconds",
        skip_serializing_if = "Option::is_none"
    )]
    pub network_period_ingress_period_grpc_read_timeout_seconds: Option<i32>,
    /// Allows to define response headers
    #[serde(
        rename = "network.ingress.extra_headers",
        skip_serializing_if = "Option::is_none"
    )]
    pub network_period_ingress_period_extra_headers: Option<String>,
    /// Percentage value of cpu usage at which point pods should scale up.
    #[serde(
        rename = "hpa.cpu.average_utilization_percent",
        skip_serializing_if = "Option::is_none"
    )]
    pub hpa_period_cpu_period_average_utilization_percent: Option<i32>,
    /// Percentage value of memory usage at which point pods should scale up.
    #[serde(
        rename = "hpa.memory.average_utilization_percent",
        default,
        with = "::serde_with::rust::double_option",
        skip_serializing_if = "Option::is_none"
    )]
    pub hpa_period_memory_period_average_utilization_percent: Option<Option<i32>>,
    /// Allows you to set an existing Kubernetes service account name
    #[serde(
        rename = "security.service_account_name",
        skip_serializing_if = "Option::is_none"
    )]
    pub security_period_service_account_name: Option<String>,
    /// Automount Kubernetes service account token to have access to Kubernetes API from pods
    #[serde(
        rename = "security.automount_service_account_token",
        skip_serializing_if = "Option::is_none"
    )]
    pub security_period_automount_service_account_token: Option<bool>,
    /// Mounts the container's root filesystem as read-only
    #[serde(
        rename = "security.read_only_root_filesystem",
        skip_serializing_if = "Option::is_none"
    )]
    pub security_period_read_only_root_filesystem: Option<bool>,
}

impl ApplicationAdvancedSettings {
    pub fn new() -> ApplicationAdvancedSettings {
        ApplicationAdvancedSettings {
            deployment_period_custom_domain_check_enabled: None,
            deployment_period_termination_grace_period_seconds: None,
            deployment_period_affinity_period_node_period_required: None,
            deployment_period_antiaffinity_period_pod: None,
            deployment_period_lifecycle_period_post_start_exec_command: None,
            deployment_period_lifecycle_period_pre_stop_exec_command: None,
            deployment_period_update_strategy_period_type: None,
            deployment_period_update_strategy_period_rolling_update_period_max_unavailable_percent: None,
            deployment_period_update_strategy_period_rolling_update_period_max_surge_percent: None,
            build_period_timeout_max_sec: None,
            build_period_cpu_max_in_milli: None,
            build_period_ram_max_in_gib: None,
            build_period_disable_buildkit_cache: None,
            network_period_ingress_period_proxy_body_size_mb: None,
            network_period_ingress_period_force_ssl_redirect: None,
            network_period_ingress_period_enable_cors: None,
            network_period_ingress_period_cors_allow_origin: None,
            network_period_ingress_period_cors_allow_methods: None,
            network_period_ingress_period_cors_allow_headers: None,
            network_period_ingress_period_proxy_buffer_size_kb: None,
            network_period_ingress_period_keepalive_time_seconds: None,
            network_period_ingress_period_keepalive_timeout_seconds: None,
            network_period_ingress_period_send_timeout_seconds: None,
            network_period_ingress_period_proxy_connect_timeout_seconds: None,
            network_period_ingress_period_proxy_send_timeout_seconds: None,
            network_period_ingress_period_proxy_read_timeout_seconds: None,
            network_period_ingress_period_proxy_buffering: None,
            network_period_ingress_period_whitelist_source_range: None,
            network_period_ingress_period_denylist_source_range: None,
            network_period_ingress_period_basic_auth_env_var: None,
            network_period_ingress_period_enable_sticky_session: None,
            network_period_ingress_period_grpc_send_timeout_seconds: None,
            network_period_ingress_period_grpc_read_timeout_seconds: None,
            network_period_ingress_period_extra_headers: None,
            hpa_period_cpu_period_average_utilization_percent: None,
            hpa_period_memory_period_average_utilization_percent: None,
            security_period_service_account_name: None,
            security_period_automount_service_account_token: None,
            security_period_read_only_root_filesystem: None,
        }
    }
}
/// Define how you want pods affinity to behave: * `Preferred` allows, but does not require, pods of a given service are not co-located (or co-hosted) on a single node * `Requirred` ensures that the pods of a given service are not co-located (or co-hosted) on a single node (safer in term of availability but can be expensive depending on the number of replicas)
#[derive(Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Serialize, Deserialize)]
pub enum DeploymentPeriodAntiaffinityPeriodPod {
    #[serde(rename = "Preferred")]
    Preferred,
    #[serde(rename = "Requirred")]
    Requirred,
}

impl Default for DeploymentPeriodAntiaffinityPeriodPod {
    fn default() -> DeploymentPeriodAntiaffinityPeriodPod {
        Self::Preferred
    }
}
/// * `RollingUpdate` gracefully rollout new versions, and automatically rollback if the new version fails to start * `Recreate` stop all current versions and create new ones once all old ones have been shutdown
#[derive(Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Serialize, Deserialize)]
pub enum DeploymentPeriodUpdateStrategyPeriodType {
    #[serde(rename = "RollingUpdate")]
    RollingUpdate,
    #[serde(rename = "Recreate")]
    Recreate,
}

impl Default for DeploymentPeriodUpdateStrategyPeriodType {
    fn default() -> DeploymentPeriodUpdateStrategyPeriodType {
        Self::RollingUpdate
    }
}
